<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Sticky Notes Grid — 3×3 in (Markdown + Print)</title>
  <style>
    :root {
      --page-width: 8.5in;
      --page-height: 11in;
      --cols: 2;
      --rows: 3;
      --note-size: 3in;
      --gap-x: 0.25in;
      --gap-y: 0.5in;
      --margin-left: 0.5in;
      --margin-top: 0.5in;
      --note-padding: 0.18in;
      --guide-color: #94a3b8; /* print guide color */
      --ui-accent: #2563eb;
      --ui-text: #e5e7eb;
      --ui-muted: #9ca3af;
      --font-stack: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
    }
    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body { margin: 0; font-family: var(--font-stack); color: var(--ui-text); background: radial-gradient(1200px 800px at 20% 0%, #111827 0%, #0b1020 55%, #05070f 100%); }

    .toolbar { position: sticky; top: 0; z-index: 10; backdrop-filter: blur(8px); background: rgba(17, 24, 39, 0.8); border-bottom: 1px solid #1f2937; padding: 0.6rem 0.9rem; display: grid; gap: 0.6rem; grid-template-columns: 1fr auto; }
    .toolbar .left, .toolbar .right { display: flex; gap: 0.6rem; align-items: center; flex-wrap: wrap; }
    .toolbar h1 { font-size: 1rem; font-weight: 600; margin: 0 0.6rem 0 0; color: #f3f4f6; }
    .toolbar label { font-size: 0.85rem; color: var(--ui-muted); }
    .toolbar input[type="number"], .toolbar select { background: #0b1220; color: #e5e7eb; border: 1px solid #243142; border-radius: 8px; padding: 0.35rem 0.5rem; outline: none; min-width: 4.5rem; }
    .toolbar input[type="checkbox"] { transform: translateY(1px); }
    .btn { background: var(--ui-accent); color: white; border: none; border-radius: 8px; padding: 0.45rem 0.7rem; font-weight: 600; cursor: pointer; transition: box-shadow 200ms ease, transform 120ms ease; }
    .btn:active { transform: translateY(1px); }
    .btn.secondary { background: #374151; }

    .sheet { width: var(--page-width); height: var(--page-height); margin: 1rem auto; background: #0a0d16; border: 1px solid #1f2937; border-radius: 12px; position: relative; overflow: hidden; box-shadow: 0 10px 30px rgba(0,0,0,0.35); }
    .grid { position: absolute; left: var(--margin-left); top: var(--margin-top); display: grid; grid-template-columns: repeat(var(--cols), var(--note-size)); grid-template-rows: repeat(var(--rows), var(--note-size)); gap: var(--gap-y) var(--gap-x); }

    body.print-guides .note { outline: 0.7pt dashed var(--guide-color); outline-offset: 0; }

    .note { width: var(--note-size); height: var(--note-size); background: white; color: #111827; border-radius: 0.05in; padding: var(--note-padding); display: grid; grid-template-rows: 1fr auto; position: relative; }
    .note textarea, .note .preview { width: 100%; height: 100%; border: none; outline: none; margin: 0; padding: 0; font: 12pt/1.25 Georgia, "Times New Roman", serif; background: transparent; color: inherit; resize: none; overflow: auto; }
    .note .preview { overflow-wrap: break-word; }

    .error-msg { display: none; margin-top: 0.2rem; font-size: 10px; color: #991b1b; }
    .note.error { border: 2px solid #ef4444; background: #fee2e2; }
    .note.error .error-msg { display: block; }

    /* Feed instruction overlay (hidden normally; shown only in print when guides are on) */
    #feedMsg { position: absolute; left: 0; right: 0; text-align: center; font: 12pt/1.2 ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial; color: #000; display: none; }

    @page { size: Letter; margin: 0; }
    @media print {
      body { background: white; }
      .toolbar { display: none !important; }
      .sheet { width: 8.5in; height: 11in; margin: 0; border: none; border-radius: 0; box-shadow: none; }
      .note textarea { display: none !important; }
      .note .preview { display: block !important; }
      .error-msg { display: none !important; }
      /* Stronger grid lines when guides enabled */
      body.print-guides .note { outline: 1.25pt solid #111 !important; }
      /* Adhesive indicator: 0.5in from top of each cell */
      body.print-guides .note::after {
        content: "";
        position: absolute;
        left: calc(var(--note-padding) / 2);
        right: calc(var(--note-padding) / 2);
        top: 0.5in; /* adhesive line position */
        height: 0;
        border-top: 1.25pt solid #111;
        opacity: 0.95;
      }
      /* Feed message only when guides enabled */
      body.print-guides #feedMsg { display: block; }
    }
  </style>
</head>
<body>
  <div class="toolbar">
    <div class="left">
      <h1>Sticky Notes Grid</h1>
      <label>Top <input id="topInput" type="number" step="0.01" min="0" value="0.5"></label>
      <label>Left <input id="leftInput" type="number" step="0.01" min="0" value="0.5"></label>
      <label>Gap X <input id="gapXInput" type="number" step="0.01" min="0" value="0.25"></label>
      <label>Gap Y <input id="gapYInput" type="number" step="0.01" min="0" value="0.50"></label>
      <label>Min font (px) <input id="minFontInput" type="number" step="1" min="3" value="4"></label>
      <label>Feed direction
        <select id="feedDir">
          <option value="Up" selected>Up</option>
          <option value="Down">Down</option>
        </select>
      </label>
      <label><input id="guidesToggle" type="checkbox"> Show print guides</label>
    </div>
    <div class="right">
      <button id="modeBtn" class="btn" title="Toggle Edit/Preview (Alt+E)">Toggle Preview (Alt+E)</button>
      <button id="clearBtn" class="btn secondary" title="Clear all notes">Clear</button>
      <button id="printBtn" class="btn" title="Print (Ctrl/Cmd+P)">Print</button>
    </div>
  </div>

  <main class="sheet">
    <section id="grid" class="grid"></section>
    <div id="feedMsg" aria-hidden="true"></div>
  </main>

  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/dompurify@3.1.6/dist/purify.min.js"></script>
  <script>
    (function(){
      const COLS=2,ROWS=3,NOTE_COUNT=COLS*ROWS,STORAGE_KEY='sticky-notes-v1',SETTINGS_KEY='sticky-notes-settings-v1';
      const grid=document.getElementById('grid'),modeBtn=document.getElementById('modeBtn'),clearBtn=document.getElementById('clearBtn'),printBtn=document.getElementById('printBtn');
      const topInput=document.getElementById('topInput'),leftInput=document.getElementById('leftInput'),gapXInput=document.getElementById('gapXInput'),gapYInput=document.getElementById('gapYInput'),guidesToggle=document.getElementById('guidesToggle'),minFontInput=document.getElementById('minFontInput'),feedDirSel=document.getElementById('feedDir');
      const feedMsg=document.getElementById('feedMsg');
      let editMode=true;

      const defaultSettings={top:0.5,left:0.5,gapX:0.25,gapY:0.5,guides:false,minFontPx:4,feedDir:'Up'};
      let settings={...defaultSettings};
      try{const saved=JSON.parse(localStorage.getItem(SETTINGS_KEY)); if(saved) settings={...settings,...saved};}catch{}
      topInput.value=settings.top; leftInput.value=settings.left; gapXInput.value=settings.gapX; gapYInput.value=settings.gapY; guidesToggle.checked=!!settings.guides; minFontInput.value=settings.minFontPx; feedDirSel.value=settings.feedDir;

      function applySettings(){
        document.documentElement.style.setProperty('--margin-top',Number(topInput.value)+'in');
        document.documentElement.style.setProperty('--margin-left',Number(leftInput.value)+'in');
        document.documentElement.style.setProperty('--gap-x',Number(gapXInput.value)+'in');
        document.documentElement.style.setProperty('--gap-y',Number(gapYInput.value)+'in');
        document.body.classList.toggle('print-guides',guidesToggle.checked);
        settings={top:Number(topInput.value),left:Number(leftInput.value),gapX:Number(gapXInput.value),gapY:Number(gapYInput.value),guides:!!guidesToggle.checked,minFontPx:parseInt(minFontInput.value,10)||4,feedDir:feedDirSel.value};
        localStorage.setItem(SETTINGS_KEY,JSON.stringify(settings));
        // Update feed instruction text & position
        updateFeedMsg();
        // Re-adjust any visible previews after layout changes
        requestAnimationFrame(()=>adjustAllVisible());
      }

      function updateFeedMsg(){
        const dir=settings.feedDir||'Up';
        const face = dir==='Up' ? 'up' : 'down';
        const arrow = dir==='Up' ? '˄' : '˅';
        feedMsg.textContent = `Face this side ${face} and feed ${arrow}`;
        // Positioning
        if(dir==='Up'){
          feedMsg.style.bottom = '0.2in';
          feedMsg.style.top = '';
          feedMsg.style.transform = 'none';
        } else {
          feedMsg.style.top = '0.2in';
          feedMsg.style.bottom = '';
          feedMsg.style.transform = 'rotate(180deg)';
        }
      }

      function createNote(i,text=''){
        const note=document.createElement('article');
        note.className='note';
        note.dataset.index=String(i);
        const ta=document.createElement('textarea'); ta.value=text;
        const pv=document.createElement('div'); pv.className='preview';
        const err=document.createElement('div'); err.className='error-msg'; err.setAttribute('aria-live','polite');
        note.append(ta,pv,err);
        queueMicrotask(()=>{ const cs=getComputedStyle(pv); const px=parseFloat(cs.fontSize)||16; note.dataset.defaultFontPxPreview=String(px); });
        ta.addEventListener('blur',()=>{ note.dataset.needsAdjust='1'; });
        const ro=new ResizeObserver(()=>{ if(isVisible(pv)) adjustNoteVisible(note); });
        ro.observe(pv);
        return note;
      }

      function saveAll(){const data=[];grid.querySelectorAll('textarea').forEach(t=>data.push(t.value));localStorage.setItem(STORAGE_KEY,JSON.stringify(data));}
      function loadAll(){try{const raw=JSON.parse(localStorage.getItem(STORAGE_KEY));return Array.isArray(raw)?raw:Array(NOTE_COUNT).fill('');}catch{return Array(NOTE_COUNT).fill('');}}

      function setMode(isEdit){
        editMode=isEdit;
        grid.querySelectorAll('.note').forEach(n=>{
          const ta=n.querySelector('textarea'),pv=n.querySelector('.preview');
          if(isEdit){
            ta.style.display='block';
            pv.style.display='none';
          } else {
            ta.style.display='none';
            pv.style.display='block';
            pv.innerHTML=DOMPurify.sanitize(marked.parse(ta.value||''));
            nextFrame(()=>{
              adjustNoteVisible(n);
              n.dataset.needsAdjust='';
            });
          }
        });
      }

      function isVisible(el){ return el && getComputedStyle(el).display!=='none' && el.offsetParent!==null; }
      function nextFrame(cb){ requestAnimationFrame(()=>requestAnimationFrame(cb)); }

      function fits(el){ return el.scrollHeight<=el.clientHeight && el.scrollWidth<=el.clientWidth; }
      function setFontPx(el,px){ el.style.fontSize=px+'px'; }
      function getDefaultPreviewPx(note){ return parseFloat(note.dataset.defaultFontPxPreview)||16; }

      // Largest-fitting binary search on VISIBLE preview
      function adjustNoteVisible(note){
        const ta=note.querySelector('textarea');
        const pv=note.querySelector('.preview');
        const err=note.querySelector('.error-msg');
        if(!isVisible(pv)) return;
        const minPx = parseInt(minFontInput.value,10) || 4;
        const defPx = getDefaultPreviewPx(note);

        // Sync markup
        pv.innerHTML = DOMPurify.sanitize(marked.parse(ta.value||''));

        // If default fits, use it and clear error
        setFontPx(pv, defPx);
        if(fits(pv)) { clearError(note, err); return; }

        // Binary search to find the LARGEST size that fits in [minPx, defPx]
        let low=minPx, high=defPx, best=minPx;
        for(let i=0;i<20;i++){ // cap iterations
          const mid = (low + high) / 2;
          setFontPx(pv, mid);
          if(fits(pv)) { best = mid; low = mid; } else { high = mid; }
          if(high - low < 0.1) break; // precision threshold
        }
        setFontPx(pv, Math.max(best, minPx));

        if(!fits(pv) && Math.abs(best - minPx) < 0.11){
          note.classList.add('error');
          const msg = `Content exceeds available space. Minimum font ${minPx}px reached.`;
          note.title = msg; err.textContent = msg;
        } else {
          clearError(note, err);
        }
      }

      function clearError(note, err){ note.classList.remove('error'); note.removeAttribute('title'); if(err) err.textContent=''; }

      function adjustAllVisible(){
        grid.querySelectorAll('.note').forEach(n=>{ const pv=n.querySelector('.preview'); if(isVisible(pv)) adjustNoteVisible(n); });
      }

      function init(){
        document.documentElement.style.setProperty('--cols',COLS);
        document.documentElement.style.setProperty('--rows',ROWS);
        const vals=loadAll();
        for(let i=0;i<NOTE_COUNT;i++){ grid.appendChild(createNote(i, vals[i]||'')); }
        setMode(true); applySettings(); updateFeedMsg();
      }

      modeBtn.addEventListener('click',()=>setMode(!editMode));
      clearBtn.addEventListener('click',()=>{ if(confirm('Clear all notes?')){ localStorage.removeItem(STORAGE_KEY); grid.querySelectorAll('textarea').forEach(t=>t.value=''); saveAll(); grid.querySelectorAll('.note').forEach(n=>{ const pv=n.querySelector('.preview'); setFontPx(pv, getDefaultPreviewPx(n)); clearError(n, n.querySelector('.error-msg')); }); if(!editMode) setMode(false); }});
      printBtn.addEventListener('click',()=>{ if(editMode) setMode(false); nextFrame(()=>{ adjustAllVisible(); window.print(); }); });
      [topInput,leftInput,gapXInput,gapYInput,minFontInput,feedDirSel].forEach(inp=>inp.addEventListener('input',applySettings));
      guidesToggle.addEventListener('change',applySettings);
      document.addEventListener('keydown',e=>{ if(e.altKey&&e.key.toLowerCase()==='e'){ e.preventDefault(); setMode(!editMode); }});
      grid.addEventListener('input',()=>saveAll());
      grid.addEventListener('blur', e=>{ const note=e.target && e.target.closest && e.target.closest('.note'); if(note) note.dataset.needsAdjust='1'; }, true);

      const mo=new MutationObserver(()=>{ if(!editMode) nextFrame(()=>{ grid.querySelectorAll('.note').forEach(n=>{ if(n.dataset.needsAdjust && isVisible(n.querySelector('.preview'))) { adjustNoteVisible(n); n.dataset.needsAdjust=''; } }); }); });
      mo.observe(grid,{subtree:true, attributes:true, attributeFilter:['style','class']});

      init();
    })();
  </script>
</body>
</html>
